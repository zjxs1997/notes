# shell

参考这个[链接](https://wangdoc.com/bash/intro.html)

## 快捷键

- `ctrl + l` 作用似乎等同于clear命令，不过会保持当前输入的命令

- `Ctrl + u` 在bash中的作用是，删除光标位置到行首的所有内容，但是在zsh中会删掉整行内容。

- `Ctrl + k` 会删掉当前光标到行尾的所有内容。

- `Ctrl + a` 可以回到行首。`Ctrl + e` 可以到行尾。（Home键有同样的效果，相对地，End键可以跳转到行尾）

## 扩展模式

可以自己设置是否开启扩展模式。`set -o noglob`或`set -f`就是关闭扩展模式，而`set +o noglob`或`set +f`开启扩展。

### 波浪线扩展

应该是最熟悉的了。`~`表示的就是home目录，`~user`就表示用户user的home目录。

### `?`扩展

`?`代表文件路径里任意一个字符，不包括空。假如当前目录下存在文件a.txt、b.txt与ab.txt，使用命令`ls ?.txt`会的返回前两个。使用echo命令也有一样的效果。但是如果匹配失败的话，ls会返回无法匹配，而echo会原样输出。

### `*`扩展

`*`表示文件路径中任意数量的字符，包括0个。比如要ls当前目录下所有py文件，以后再也不用`ls | grep py`了，可以直接`ls *.py`。

不过`*`不会匹配隐藏文件。如果要匹配，需要写成`echo .*`。输出的模式与`?`一样，只有匹配成功才会输出。

另外，`*`只会匹配当前目录，想要匹配子目录就需要`ls */*.txt`。不过有引入一个参数`globstar`，当它被打开的时候，允许`**`匹配子目录。

### 方括号扩展

和正则表达式一样，匹配方括号中任意一个字符，用`[!abc]`表示匹配除了abc之外的所有字符。`[0-9]`表示匹配0到9的所有数字字符。

### 大括号扩展

方括号扩展的语义类似于或，而大括号扩展的语义类似于和。比如`echo a{a,b}`会输出aa和ab。

### 变量扩展

`echo $SHELL`，也可以`echo ${SHELL}`用来输出变量SHELL的值。

### 子命令扩展

`$(...)`可以扩展成一个命令的运行结果，比如`echo $(date)`

## 变量

bash里的所有变量都是字符串（大概），用等号赋值，并且等号两边不能有空格`a=USER`。

读取变量的值，只需要用$符号`echo $a`，或者可以用一个大括号括起来，这样更保险。（比如zsh中，紧跟在变量后面的:l会被视为参数的lower表示，导致某些命令出问题）。如果变量的值本身也是变量的名字，想通过这个名字访问变量，可以用`echo ${!a}`，返回用户的名字。不过注意这个语法似乎只在bash中成立。

用户创建的变量只用于当前shell，子shell读取不到父shell定义的变量。为了传递变量的值，需要使用export命令。这样输出的变量，对于子shell来说就是环境变量。可以先定义一个变量，然后用`export 变量名`的方式，也可以直接`export 变量名=变量值`。

## 行操作

bash内置了readline库，提供了很多行操作的功能。默认采用的是emacs快捷键，也可以设置成vi快键键模式。`set -o vi/emacs`。有些功能已经在快捷键那一节写过了。

### 光标移动

- `ctrl + a` 移动到行首；`ctrl + e` 移动到行尾。

- `alt + f` 移动到当前单词的词尾；`alt + b` 移动到当前单词的词首。（应该是forward和backward吧，但是感觉有点怪怪的）

- `ctrl + b` 向行首移动一个字符，左箭头；`ctrl + f` 向行尾移动一个字符，右箭头。

### 编辑操作

- `ctrl + d` 删除光标位置的字符，相当于del。（如果当前行没有任何字符，会导致退出shell）

- `ctrl + w` 删除光标前面的单词

- `ctrl + t` 光标位置的字符与前一位字符交换位置； `alt + t` 光标位置的词与它前一个词交换位置。

- `alt + l` 将光标位置至词尾转换成小写，`alt + u` 大写。

（有些命令真的会用到吗orz，这么麻烦还不如在文本编辑器里写完命令复制粘贴呢。。。）

### 关于历史记录

退出当前shell的时候，shell会讲用户在当前shell操作的历史写入到`~/.xx_history`，xx是shell的名字。bash默认是500个操作，zsh则大大超过这个值。。。`history`命令则是读取这个文件。

`!e`表示找出操作历史中最接近的以e开头的命令并执行，在zsh中会把这条命令恢复到当前行，可以进行一些编辑后再执行。同样也有`!echo`这样的用法。不过这种语法只匹配命令，不匹配参数。有个特殊语法`!!`，执行上一个命令。常用于这种情况：执行命令发现忘记加sudo了导致失败，可以使用`sudo !!`快捷执行。

按下`ctrl + r`会显示操作历史，可以用上下键移动并选择。

`alt + .`可以插入上一个命令的最后一个词。一般这个词都是文件路径，所以有时会很方便。

## 目录相关

用`cd -`命令可以回到之前的目录。

pushd和popd命令。`pushd dirname`会进入dirname目录，并且将该目录push到stack的顶部。如果是第一次执行pushd命令，则会讲当前目录先push到stack。用`popd`命令的时候，会先pop出stack顶部的元素，然后cd到新的栈顶的目录。-n参数表示命令仅操作stack，不改变目录。

`dirs`命令可以查看stack内容。

## 关于脚本的执行

如果用bash执行脚本，是新开一个子shell在里面执行。但是如果用source执行，则是在当前shell执行脚本。比如有个脚本`echo $foo`，在shell里`foo=1`，不需要export，用source执行脚本的时候也可以正常输出1。

source更常见的用处是重载配置文件，或是加载外部库。source有简写形式，就是用一个.来表示：`. .bashrc`

## 判断与条件语句

if语句：

```sh
if commands; then
    commands
[elif commands; then
    commands]
[else
    commands]
fi
```

if与then同行时，需要分号分隔。if之后的commands的最后一条命令返回0，则表示判断条件成立。

### 判断条件（命令）

有三种写法，`test expression`；`[ expression ]`和`[[ expression ]]`。expression是一个表达式，如果表达式为真，则test命令执行成功，返回0。

`test -f /etc/hosts`命令用来查看是否存在这个文件（并且是普通文件）。执行完后可以用`echo $?`检查结果，输出0表示存在这个文件。命令`[ -f /etc/hosts ]`与其等价。

### 判断规则

除了-f判断普通文件之外，还有很多规则，这里也不写了，参考这个[链接](https://wangdoc.com/bash/condition.html#%E6%96%87%E4%BB%B6%E5%88%A4%E6%96%AD)。

关于字符串的判断，主要有`[ s1 = s2 ]`判断相等；`[ s1 '>' s2 ]`判断字典序；`[ -n s1 ]`判断长度是否大于0；`[ -z s1 ]`判断长度是否为0。注意大于小于号必须用引号，否则会被视为重定向符。再强调一下中括号必须要用空格隔开。

整数判断有这些：`[ i1 -eq i2 ]`判断是否相等；`[ i1 -ne i2 ]`是否不等；同样还有le表示小于等于；lt小于；ge与gt。

逻辑运算符号，`!`，`&&`与`||`。

顺带一提，如果对于普通命令用`&&`与`||`：`cmd1 && cmd2`与`cmd1 || cmd2`。发生的事情是这样的：如果cmd1执行成功（即返回0），那么第一个命令中的cmd2会执行，第二个命令中的cmd2不执行；反之cmd1执行失败（返回非0），那么前一个cmd2不执行，后一个执行。

## 循环

和大部分编程语言一样，有while、until和两种for循环（for in、c风格for）。也有关键词break和continue。

### while循环

```sh
while condition; do
    commands
done
```

condition的写法与if中的一致。

### until循环

```sh
until condition; do
    commands
done
```

### for in循环

```sh
for variable in list; do
    commands
done
```

每次从list列表中取出一项作为变量，然后执行循环体。列表可以手动写`for i in w1 w2 w3`，也可以用通配符`for i in *.png`，还可以通过子命令`for i in $(cat ~/.bashrc)`（这个命令会便利每个词）

## 函数

老朋友了，定义函数可以用`fn() {}`或`function fn() {}`。参数名字规则和脚本里都差不多。

函数里声明的变量属于全局变量。可以用local声明局部变量。

## shell启动环境

（这里都用bash举例，事实上zsh应该也差不多）

每次使用shell的时候，都会开启一个session。session分两类，登陆session与非登陆session。退出session的时候会执行`~/.bash_logout`。需要用账号密码登陆的shell，或者用`bash -l/--login`创建的都是登陆shell。在命令行中执行`bash`就会创建一个非登陆session。

此外还有交互式与非交互式的分类方式，这个就比较直观了，就看你在shell中能不能交互式地输入命令得到结果。比如`bash a.sh`肯定是非交互式的，`bash`创建新的session肯定是交互式的。

这样就可以分成四类。ssh登陆到服务器，显然是交互式登陆；在ssh之后用bash，这是交互式非登陆；用scp传文件，应该是非交互式登陆；在ssh之后用bash执行某个脚本，是非交互式非登陆。
此外，在桌面环境中开启一个新的终端模拟器似乎是交互式非登陆；但是在mac上貌似又是登陆？？？晕。

### 登陆session

是登陆系统之后，系统为用户开的原始session。会对系统环境进行初始化，依次启动如下脚本：

- `/etc/profile`，所有用户的全局配置脚本；`/etc/profile.d`目录里的所有扩展名为sh的文件。

- `~/.bash_profile`，如果该脚本存在则不再往下执行。之后是`~/bash_login`之类的，反正我也不用，不记了。

一般会在`~/.bash_profile`中写入：

```sh
if [ -f ~/.bashrc ]; then
    . ~/.bashrc
fi
```

用`~/.bashrc`来初始化。

！！！注意：在非交互式登陆中，似乎是直接执行`~/.bashrc`的，因此`~/.bashrc`的执行结果中不应该有回显或者输出任何内容。
这是我之前踩过的坑。在`~/.bashrc`里写了几行，进入zsh。这样显然会导致scp（非交互式登陆）出问题。

使用`bash --login`命令可以强制执行登陆session要执行的脚本。

### 非登陆session

是用户进入系统后手动创建的session。它会依次执行如下脚本：

- `/etc/bash.bashrc`

- `~/.bashrc`

## 命令提示符

这部分属于hack内容，可以调教一个比较好看的界面出来。如果还想hack，可以参考这个[链接](https://wangdoc.com/bash/prompt.html)

环境变量PS1决定了命令提示符，这个其实已经hack的比较多了，这里也不写了。

除此之外，还有PS2环境变量，这个是命令行折行输入时的提示符，比如命令写到一半写了个\，然后敲回车，就会出现一个`>`（加一个空格）提示你接下来要写什么命令。

PS3和PS4反正我也不怎么用，不写了。

